% nearest-neighbor method

function [myTimes,mySat_name,myChNum,myLat,myLon,myTb,myROI_hydro,myROI_other,myObsErr,mySat_alt] = ProduceForEnKF(istorm, DAtime, Ch, Tb_file, control)

    % -------------------------------------------------------------------------------------
    % Read and sligtly process lat, lon, Tb from the GOESR file 
    % -------------------------------------------------------------------------------------

    Tbs = ncread(Tb_file, 'CMI');
    % vairables about lat/lon
    x=ncread(Tb_file,'x');
    y=ncread(Tb_file,'y');
    % lat/lon;
    req=6378137;
    rpol=6356752.31414;
    H=42164160;
    l0=ncread(Tb_file,'nominal_satellite_subpoint_lon')*pi/180;
    [y2d,x2d]=meshgrid(y,x);
    a=(sin(x2d)).^2+(cos(x2d)).^2.*((cos(y2d)).^2+(req/rpol.*sin(y2d)).^2);
    b=-2.*H.*cos(x2d).*cos(y2d);
    c=H.^2-req.^2;
    r=(-b-sqrt(b.^2-4.*a.*c))/2./a;
    sx=r.*cos(x2d).*cos(y2d);
    sy=-r.*sin(x2d);
    sz=r.*cos(x2d).*sin(y2d);
    lat=atan(req.^2./rpol.^2.*sz./sqrt((H-sx).^2+sy.^2));
    lon=l0-atan(sy./(H-sx));
    lat=lat*180/pi;
    lon=lon*180/pi;
    lat(find(imag(lat)))=NaN;
    lon(find(imag(lon)))=NaN;
    % get rid of points with Nan values
    idx_noNan = ~isnan(lat);
    lat_col = lat(idx_noNan);
    lon_col = lon(idx_noNan);
    Tb_col = Tbs(idx_noNan);  
    
    % -------------------------------------------------------------------------
    % Read domain of interest from geo_em.d03.nc generated by WPS geogrid.exe
    % ------------------------------------------------------------------------
    geo_file =  [control.geogrid_dir,control.storm_phase{istorm},'/',DAtime,'/geo_em.',control.domain,'.nc'];
    disp(['Reading ', geo_file, '......']);
    xlat_m = ncread(geo_file,'XLAT_M'); 
    xlon_m = ncread(geo_file,'XLONG_M');
    min_xlat = min(xlat_m,[],'all')-0.05;
    max_xlat = max(xlat_m,[],'all')+0.05;
    min_xlon = min(xlon_m,[],'all')-0.05;
    max_xlon = max(xlon_m,[],'all')+0.05;

    % ---------------------------------------------------------------------------
    % Separate model grids in the domain of interest into different groups for ROI plans
    % ---------------------------------------------------------------------------
    % Separate gird points for ROI plan 1 from ROI plan 2
    % Original grid points:         Filtered grid points for one ROI:
    %       * * * * *                *   *   * 
    %       * * * * *                          
    %       * * * * *                *   *   * 
    %       * * * * *                          
    %       * * * * *                *   *   * 

    % reduce workload by find the approximate area of interest
    idx_inArea = (lat_col >= min_xlat) & (lat_col <= max_xlat) & (lon_col >= min_xlon) & (lon_col <= max_xlon);
    lat_obs = lat_col(idx_inArea);
    lon_obs = lon_col(idx_inArea);
    Tb_obs = Tb_col(idx_inArea);
    
    % initialize an empty container for indices of obs to be selected for ROI plans
    obs_index = cell(size(control.roi_oh));      
    % locate the start point of model grid for each ROI plan
    filter_grid_step = control.filter_reso / control.dx;
    grid_start(2) = floor(filter_grid_step(2) / 2); % start point for ROI plan 1 
    grid_start(1) = grid_start(2) + .5*(2*filter_grid_step(2) - filter_grid_step(1)); % start point for ROI plan 2 

    t_Start_filter = tic;
    parpool(48); % use 48 cores in a node   
    % loop through each ROI plan to filter grids and obtain GOESR obs for filtered points
    for iroi = 1:length(control.roi_oh)
        disp(['  Resolution to be filtered for this ROI is : ', num2str(control.filter_reso(iroi)), 'km ......']);
        if iroi == 1
            lat_obs_toPick = lat_obs; lon_obs_toPick = lon_obs;
        end
        [lat_obs_toPick, lon_obs_toPick, idx_PickObs] = PickRawforCRTM(lat_obs_toPick,lon_obs_toPick,xlat_m,xlon_m,grid_start(iroi),filter_grid_step(iroi),control);
        obs_index{iroi} = ;
        [v, w] = unique(obs_index{iroi},'stable' );
        duplicate_idx = setdiff(1:numel(obs_index{iroi}),w );
        if sum(duplicate_idx) ~= 0 
            warning(['  Number of repeated obs selected for this ROI selection: ', num2str(length(duplicate_idx))]);
        end
    end
    delete(gcp('nocreate')); % shut down current parallel pool
    t_End_filter = toc(t_Start_filter);
    disp(['Picking the nearest obs for model grids for all ROI plans takes ', num2str(t_End_filter), ' seconds.']);    

    % find the possible repeated selected obs for all ROI plans
    [Cdata] = intersect(obs_index{1},obs_index{2});
    if sum(Cdata) ~= 0
        disp(['Number of repeated obs across all ROI selections: ', num2str(length(Cdata))]);
    end

    % ------------------------------------------------------------------------- 
    % Process and collect obs for each ROI plan 
    % -------------------------------------------------------------------------

    % Preallocating memory
    myTimes = cell(size(control.roi_oh));
    mySat_name = cell(size(control.roi_oh));
    myChNum = cell(size(control.roi_oh));
    myLat = cell(size(control.roi_oh));
    myLon = cell(size(control.roi_oh));
    myTb  = cell(size(control.roi_oh));
    myROI_hydro = cell(size(control.roi_oh));
    myROI_other = cell(size(control.roi_oh));
    myObsErr = cell(size(control.roi_oh));
    mySat_alt = cell(size(control.roi_oh));

    for iroi = 1:length(control.roi_oh) % ROI first references [200,0] second [30,30]
        obs_index_array = obs_index{iroi};
        obs_index_1d = obs_index_array(obs_index_array(:) == obs_index_array(:)); % get rid of obs_index with value NaN
        lat = lat_obs(obs_index_1d);
        lon = lon_obs(obs_index_1d);
        Tb = Tb_obs(obs_index_1d);
        %randOrder = randperm(length(cat(1,Tb(:)))); randomize IR records for this ROI
        myTimes{iroi} = repmat(string(DAtime), length(Tb), 1);
        mySat_name{iroi} = repmat("abi_gr", length(Tb), 1);
        myChNum{iroi} = repmat(Ch, length(Tb), 1);  
        myLat{iroi} = lat; myLon{iroi} = lon; myTb{iroi} = Tb;
        myROI_hydro{iroi} = repmat(control.roi_oh{iroi}(2), length(Tb), 1); 
        myROI_other{iroi} = repmat(control.roi_oh{iroi}(1), length(Tb), 1);
        myObsErr{iroi} =  repmat(control.obsError, length(Tb), 1);   
        mySat_alt{iroi} = repmat(control.Sat_alt, length(Tb), 1);    
    end

    % -------------------------------------------------------------------------
    % Function to find the nearest obs for filtered WRF grids    
    % -------------------------------------------------------------------------
    function [ obs_lat, obs_lon, idx_getObs ] = PickRawforCRTM(obs_lat,obs_lon,m_xlat,m_xlon,start_grid,step_grid,control)

        % Filter lat and lon of WRF domain for each ROI
        idx_step = start_grid:step_grid:size(m_xlat,1); % xlat_m/xlon_m has same dimension value along x and y axis 
        xlat = m_xlat(idx_step, idx_step);
        xlon = m_xlon(idx_step, idx_step);
        xlat_col = xlat(:);
        xlon_col = xlon(:);    

        % For each WRF grid of interest, select the nearest obs 
        idx_getObs = nan(length(xlon_col),1);

        for id =1:length(xlon_col)
            dis_ig = distance(xlat_col(id),xlon_col(id),obs_lat,obs_lon);
            idx = find( dis_ig == min(dis_ig) );
            % Get the obs index 
            idx_getObs(id,1) = idx;
            % Mark the selected obs and gurantee it will be never used again
            obs_lat(idx) = nan; obs_lon(idx) = nan; 
        end
    end

end
